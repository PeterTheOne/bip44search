{"version":3,"sources":["../../src/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["hdnode","App","useState","seed","setSeed","deriPaths","name","rpc","blockscout","networks","currentMsg","setCurrentMsg","results","setResults","search","a","console","log","error","bip44search","msg","entry","re","onSubmit","e","preventDefault","Input","value","onChange","currentTarget","Button","type","Table","map","result","path","network","address","balance","txCount","tokens","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e296c41e.chunk.js","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar hdnode_1 = require(\"@ethersproject/hdnode\");\nvar web3_1 = __importDefault(require(\"web3\"));\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nfunction getTokenlist(blockscoutBase, address) {\n    return __awaiter(this, void 0, void 0, function () {\n        var resp;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, cross_fetch_1.default(blockscoutBase + \"/api?module=account&action=tokenlist&address=\" + address, {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json',\n                        },\n                    })];\n                case 1:\n                    resp = _a.sent();\n                    return [4 /*yield*/, resp.json()];\n                case 2: \n                // todo: validate response\n                return [2 /*return*/, (_a.sent()).result];\n            }\n        });\n    });\n}\nfunction bip44search(mnemonicOrPrivateKey, derivationPaths, networks, callback, callback2) {\n    return __awaiter(this, void 0, void 0, function () {\n        var hdnode, web3, _i, derivationPaths_1, deriPath, firstIndex, untilIndex, index, deriPathIndex, deriNode, _a, networks_1, network, entry, balance, txCount, tokens;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (hdnode_1.isValidMnemonic(mnemonicOrPrivateKey)) {\n                        hdnode = hdnode_1.HDNode.fromMnemonic(mnemonicOrPrivateKey);\n                    }\n                    else {\n                        // throw Error('Only seed from Mnemonic supported');\n                        // todo: support private key.\n                        return [2 /*return*/];\n                    }\n                    _i = 0, derivationPaths_1 = derivationPaths;\n                    _b.label = 1;\n                case 1:\n                    if (!(_i < derivationPaths_1.length)) return [3 /*break*/, 11];\n                    deriPath = derivationPaths_1[_i];\n                    firstIndex = parseInt((/[^/]*$/.exec(deriPath) || ['0'])[0], 10);\n                    untilIndex = firstIndex + 1;\n                    index = firstIndex;\n                    _b.label = 2;\n                case 2:\n                    if (!(index < untilIndex)) return [3 /*break*/, 10];\n                    deriPathIndex = deriPath.substring(0, deriPath.lastIndexOf('/')) + \"/\" + index;\n                    deriNode = hdnode.derivePath(deriPathIndex);\n                    callback(\"Searching \" + deriPathIndex + \": \" + deriNode.address);\n                    _a = 0, networks_1 = networks;\n                    _b.label = 3;\n                case 3:\n                    if (!(_a < networks_1.length)) return [3 /*break*/, 9];\n                    network = networks_1[_a];\n                    callback(\"Searching \" + network.name);\n                    web3 = new web3_1.default(network.rpc);\n                    entry = {\n                        path: deriPathIndex,\n                        address: deriNode.address,\n                        network: network.name,\n                    };\n                    return [4 /*yield*/, web3.eth.getBalance(deriNode.address)];\n                case 4:\n                    balance = _b.sent();\n                    if (parseInt(balance, 10) > 0) {\n                        callback(\"Native balance: \" + balance);\n                        untilIndex = index + 2;\n                    }\n                    entry.balance = balance;\n                    return [4 /*yield*/, web3.eth.getTransactionCount(deriNode.address)];\n                case 5:\n                    txCount = _b.sent();\n                    if (txCount > 0) {\n                        callback(\"Transactions:   \" + txCount);\n                        untilIndex = index + 2;\n                    }\n                    entry.txCount = txCount;\n                    if (!network.blockscout) return [3 /*break*/, 7];\n                    return [4 /*yield*/, getTokenlist(network.blockscout, deriNode.address)];\n                case 6:\n                    tokens = _b.sent();\n                    if (tokens.length > 0) {\n                        callback(\"Tokens:         \" + tokens.length);\n                        untilIndex = index + 2;\n                    }\n                    entry.tokens = tokens.length;\n                    _b.label = 7;\n                case 7:\n                    if (callback2) {\n                        callback2(entry);\n                    }\n                    _b.label = 8;\n                case 8:\n                    _a++;\n                    return [3 /*break*/, 3];\n                case 9:\n                    index += 1;\n                    return [3 /*break*/, 2];\n                case 10:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 11:\n                    callback('Done');\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.default = bip44search;\n//# sourceMappingURL=index.js.map","import React, { useState } from 'react';\nimport { Button, Input, Table } from 'reactstrap';\nimport bip44search, { Entry } from 'bip44search-cli';\nimport { Network } from 'bip44search-cli/build/networks';\n\nexport default function App(): JSX.Element {\n  const [seed, setSeed] = useState<string>('');\n  const [deriPaths, setDeriPaths] = useState<string[]>([\n    \"m/44'/60'/0'/0/0\",\n    \"m/44'/60'/0'/0\",\n    \"m/44'/60'/0'\",\n    \"m/44'/1'/0'/0\",\n  ]);\n  const [networks, setNetworks] = useState<Network[]>([\n    {\n      name: 'ARTIS sigma1',\n      rpc: 'https://rpc.sigma1.artis.network',\n      blockscout: 'https://blockscout.com/artis/sigma1',\n    },\n    {\n      name: 'xDai Chain',\n      rpc: 'https://dai.poa.network',\n      blockscout: 'https://blockscout.com/poa/xdai',\n    },\n    {\n      name: 'POA Network',\n      rpc: 'https://core.poa.network',\n      blockscout: 'https://blockscout.com/poa/core',\n    },\n  ]);\n  const [currentMsg, setCurrentMsg] = useState<string>('');\n  const [results, setResults] = useState<Entry[]>([]);\n  const search = async () => {\n    console.log('w00t');\n\n    if (!seed || seed === '') {\n      console.error('no seed: do nothing. :(');\n      return;\n    }\n    setResults([]);\n    await bip44search(seed, deriPaths, networks, (msg) => {\n      setCurrentMsg(msg);\n    }, (entry) => {\n      setResults((re) => [...re, entry]);\n    });\n  };\n\n  return (\n    <div>\n      <div>\n        <h1>bip44search</h1>\n        <p>*desc*</p>\n      </div>\n      <div>\n        <h2>Seed Phrase</h2>\n        <form\n          onSubmit={(e) => {\n            e.preventDefault();\n            search();\n          }}\n        >\n          <Input value={seed} onChange={(e) => setSeed(e.currentTarget.value)} />\n          <Button type=\"submit\">Search</Button>\n        </form>\n        <p>todo</p>\n      </div>\n      <div>\n        <h2>Networks</h2>\n        <p>todo</p>\n      </div>\n      <div>\n        <h2>Derivation Paths</h2>\n        <p>todo</p>\n      </div>\n      <div>\n        <h2>Results</h2>\n        <p>\n          {currentMsg}\n        </p>\n        <Table>\n          <thead>\n            <tr>\n              <th>Path</th>\n              <th>Network</th>\n              <th>Address</th>\n              <th>Balance</th>\n              <th>Transactions</th>\n              <th>Tokens</th>\n            </tr>\n          </thead>\n          <tbody>\n            {results.map((result) => (\n              <tr key={result.path + result.network + result.address}>\n                <td>{result.path}</td>\n                <td>{result.network}</td>\n                <td>{result.address}</td>\n                <td>{result.balance}</td>\n                <td>{result.txCount}</td>\n                <td>{result.tokens}</td>\n              </tr>\n            ))}\n          </tbody>\n        </Table>\n      </div>\n    </div>\n  );\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost'\n  // [::1] is the IPv6 localhost address.\n  || window.location.hostname === '[::1]'\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  || window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n  ),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config): void {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href,\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service '\n            + 'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config): void {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      // eslint-disable-next-line no-param-reassign\n      registration.onupdatefound = (): void => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = (): void => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all '\n                + 'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config): void {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404\n        || (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.',\n      );\n    });\n}\n\nexport function unregister(): void {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './style/main.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}